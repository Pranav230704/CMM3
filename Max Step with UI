import numpy as np
import yaml
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
import tkinter as tk
from tkinter import ttk
from datetime import datetime
from meteostat import Point, Hourly
from scipy.optimize import curve_fit

# Define coordinates for additional cities
cities = {
    'Edinburgh': Point(55.9533, -3.1883),
    'Oslo': Point(59.9139, 10.7522),
    'Toronto': Point(43.65107, -79.347015),
    'Nairobi': Point(-1.286389, 36.817223),
    'Rio': Point(-22.9068, -43.1729),
    'Cape Town': Point(-33.9249, 18.4241)
}

# Define T_amb_list as a global variable
T_amb_list = []

# Function to get temperature for selected city
def get_temperature_for_city(city_name):
    global T_amb_list  # Declare as global to update the global variable
    location = cities.get(city_name)
    if location:
        # Set the time period for data retrieval
        start = datetime(2023, 1, 1, 0)  # Start time
        end = datetime(2023, 1, 2, 0)  # End time (24-hour period)
        # Fetch hourly temperature data
        data = Hourly(location, start, end)
        data = data.fetch()
        T_amb_list = data['temp'].tolist()
        return T_amb_list
    else:
        return []

# Function to update temperature based on selected city
def update_temperature():
    selected_city = city_var.get()
    global T_amb_list  # Declare as global to use the updated list
    T_amb_list = get_temperature_for_city(selected_city)
    if T_amb_list:
        print(f"Temperature data for {selected_city} fetched successfully!")
    else:
        print(f"Failed to fetch temperature data for {selected_city}.")
    # You can further display or use this T_amb_list in the simulation as needed
#open cop yaml file
file_path1 = r'/Users/pranav/Downloads/heat_pump_cop_synthetic_full.yaml'
with open(file_path1,'r') as file :
    cop_yaml = yaml.safe_load(file)
#print(cop_yaml)
cop_temp = []
cop_cop = []

# pick out data from yam file
for i in cop_yaml['heat_pump_cop_data']:
    cop_temp.append(i['outdoor_temp_C'])
    cop_cop.append(i['COP_noisy'])
    
#print(cop_cop)
#rint(cop_temp)

class Heat_system:
    def __init__(self, Aw, Uw, Ar, Ur, T_amb_list, T_sp, U_cond, T_cond, U_tank, A_tank, c_t):
        self.Aw = Aw
        self.Uw = Uw
        self.Ar = Ar
        self.Ur = Ur
        self.T_amb_list = T_amb_list
        self.T_sp = T_sp
        self.U_cond = U_cond
        self.T_cond = T_cond
        self.U_tank = U_tank
        self.A_tank = A_tank
        self.c_t = c_t
        self.pump_on = False
        self.real_cop = []  # Store calculated COP values for averaging
        self.cop_values = []  # Store COP values at t_eval points

    def Q_load(self):
        Q_loads = []
        for Tamb in self.T_amb_list:
            Q_load = (self.Aw * self.Uw * (Tamb + 273 - self.T_sp) + self.Ar * self.Ur * (Tamb + 273 - self.T_sp)) * -1
            Q_loads.append(Q_load)
        return Q_loads

    # COP function based on curve fitting
    def cop(self, T_amb, a, b):
        delta_T = 60 - T_amb
        return a + b / delta_T

    # Fit COP parameters using the provided data once
    popt, pcov = curve_fit(lambda T, a, b: a + b / (60 - T), cop_temp, cop_cop)
    a, b = popt  # Obtained parameters for COP calculation

    def Q_hp(self, T_tank, T_amb):
        if T_tank >= 60 + 273.15:
            self.pump_on = False
        elif T_tank <= 40 + 273.15:
            self.pump_on = True

        if self.pump_on:
            
            return 1.11 * (self.U_cond * (self.T_cond - T_tank))
        else:
            return 0

    def tank_temperature_ode(self, t, T_tank):
        T_amb = np.interp(t, np.linspace(0, 86400, len(self.T_amb_list)), self.T_amb_list)
        Load = np.interp(t, np.linspace(0, 86400, len(self.Q_load())), self.Q_load())
        Q_hp = self.Q_hp(T_tank, T_amb)
        Q_loss = self.U_tank * self.A_tank * (T_tank - T_amb)
        
        dTdt = (Q_hp - Load - Q_loss[0]) / self.c_t
        return dTdt

    def solve_tank_temperature(self, initial_tank_temp, total_time=86400, time_points=1000):
        t_eval = np.linspace(0, total_time, time_points)
        
        # Interpolate T_amb_list to match the evaluation points
        T_amb_interpolated = np.interp(t_eval, np.linspace(0, 86400, len(self.T_amb_list)), self.T_amb_list)

        # Solve ODE at specified evaluation points
        solution = solve_ivp(self.tank_temperature_ode, [0, total_time], [initial_tank_temp], t_eval=t_eval, method="RK45", max_step=100)

        # Calculate COP at each t_eval point based on T_amb
        self.cop_values = [self.cop(T_amb, self.a, self.b) for T_amb in T_amb_interpolated]

        # Calculate total energy consumption
        Q_hp_values = [self.Q_hp(T_tank, T_amb) for T_tank, T_amb in zip(solution.y[0], T_amb_interpolated)]
        Q_hp_total = np.trapz(Q_hp_values, solution.t)  # Total energy consumption
        
        # Calculate average COP
        avg_cop = np.mean(self.real_cop) if self.real_cop else 0  # Average COP

        T_tank_values = solution.y[0] - 273.15  # Convert tank temperature to Celsius
        time_values = solution.t

        return time_values, T_tank_values, Q_hp_total, avg_cop

    
# Inside your run_simulation function, pass T_amb_list after fetching it
def run_simulation(Aw, Uw, Ar, Ur, T_sp, U_cond, T_cond, U_tank, A_tank, c_t, display_type):
    # Ensure that T_amb_list is updated before passing it to the Heat_System
    if not T_amb_list:
        print("Temperature data not available!")
        return
    
    heat_system = Heat_system(Aw, Uw, Ar, Ur, T_amb_list, T_sp, U_cond, T_cond, U_tank, A_tank, c_t)
    initial_tank_temp = 318.15  # Initial tank temperature in K
    time_values, T_tank_values, Q_hp_total, avg_cop = heat_system.solve_tank_temperature(initial_tank_temp)
    
    if display_type == 'Temperature':
        plt.figure(figsize=(10, 6))
        plt.plot(time_values / 3600, T_tank_values, label="Tank Temperature", linewidth=1.5)
        plt.axhline(y=60, color="red", linestyle="--", label="Heat Pump Off Threshold (60°C)")
        plt.axhline(y=40, color="blue", linestyle="--", label="Heat Pump On Threshold (40°C)")
        plt.xlabel("Time (hours)")
        plt.ylabel("Tank Temperature (°C)")
        plt.title("Tank Temperature Over Time")
        
        # Adjust y-axis to provide extra space at the top
        plt.ylim(min(T_tank_values) - 5, max(T_tank_values) + 5)
        
        # Place the legend in the top right corner within the plot area
        plt.legend(loc="upper right")
        
        plt.grid(True)
        plt.tight_layout()  # Adjust layout to fit everything nicely
        plt.show()
        
    elif display_type == 'COP over Time':
        plt.figure(figsize=(12, 6))
        plt.plot(time_values / 3600, heat_system.cop_values, label='COP', color='purple')
        plt.xlabel('Time (hours)')
        plt.ylabel('COP')
        plt.title('Coefficient of Performance (COP) Over Time')
        plt.legend()
        plt.grid(True)
        plt.show()
        
    elif display_type == 'Total Energy Consumption':
        print("")
        
        
# Update the settings dictionary to include a placeholder for the outside temperature (T_amb)
settings = {
    'A': {'Aw': 85, 'Uw': 0.4, 'Ar': 80, 'Ur': 0.15, 'T_sp': 288.15,
          'Mass of Water in Hot Water Tank in kg': 200, 
          'Initial Tank Temperature in K': 200,
          'Heat Pump On Threshold in K': 318.15, 
          'Heat Pump Off Threshold in K': 333.15,
          'Tank Surface Area in m² (A_tank)':1, 'City': 'Oslo', 'Outside Temp': 0},  # 'Outside Temp' placeholder
    'B': {'Aw': 135, 'Uw': 0.6, 'Ar': 120, 'Ur': 0.25, 'T_sp': 298.15,
          'Mass of Water in Hot Water Tank in kg': 200, 
          'Initial Tank Temperature in K': 200,
          'Heat Pump On Threshold in K': 318.15, 
          'Heat Pump Off Threshold in K': 333.15,
          'Tank Surface Area in m² (A_tank)':1, 'City': 'Cape Town', 'Outside Temp': 0},
    'C': {'Aw': 180, 'Uw': 0.8, 'Ar': 160, 'Ur': 0.3, 'T_sp': 303.15,
          'Mass of Water in Hot Water Tank in kg': 200, 
          'Initial Tank Temperature in K': 200,
          'Heat Pump On Threshold in K': 318.15, 
          'Heat Pump Off Threshold in K': 333.15,
          'Tank Surface Area in m² (A_tank)': 1, 'City': 'Nairobi', 'Outside Temp': 0},
    'D': {'Aw': 132, 'Uw': 0.51, 'Ar': 120, 'Ur': 0.18, 'T_sp': 293.15,
          'Mass of Water in Hot Water Tank in kg': 200, 
          'Initial Tank Temperature in K': 200,
          'Heat Pump On Threshold in K': 318.15, 
          'Heat Pump Off Threshold in K': 333.15,
          'Tank Surface Area in m² (A_tank)':1, 'City': 'Edinburgh', 'Outside Temp': 0},
}

root = tk.Tk()
root.title("Heat Pump Simulation")

# Add user manual as a text widget in a frame
def create_user_manual():
    user_manual = """
    Heat Pump Simulation User Manual

    This tool allows you to model and analyze the behavior of a heat pump system based on various parameters. Below is a step-by-step guide to help you get started.

1)  Select one of the preset buildings (via the dropdown menu) to set the appropriate system parameters:
    
    Building A: a well-insulated, smaller home.
    Building B: a moderately insulated, medium-sized home.
    Building C: a poorly-insulated, larger house.
    Building D: the default building given in the ‘input.yaml’ file.
    
    This will select all the inputs.
    You will know if the inputs have been selected successfully as it will state in the spyder kernal 'Temperature data for city has been fetched successfully'
    
2) Edit the parameters to suit your own inputs, if you wish to change the outside tempearture input you must click update temperature in order to update it (optional).

3) Click the run simulation button which will run the inputs using the code and output the results on our spyder code.

   (If you wish to view the performance metrics)
    
4) Select the performance metrics dropdown menu. 

5) Select the inputs you would like to view for the metric.
    
6) Click show metric.
    
7) View the metric graph on spyder.
    """
    manual_frame = tk.Frame(root)
    manual_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=20, pady=20)

    manual_label = tk.Label(manual_frame, text="User Manual", font=("Arial", 14, "bold"))
    manual_label.pack()

    manual_text = tk.Text(manual_frame, height=20, width=50, wrap=tk.WORD)
    manual_text.insert(tk.END, user_manual)
    manual_text.config(state=tk.DISABLED)  # Make the text widget read-only
    manual_text.pack()

# Create and display the user manual
create_user_manual()


# Frame for Parameters
frame_params = tk.Frame(root)
frame_params.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)


# Function to update the temperature based on selected city
def update_temperature_display(city_name):
    global T_amb_list  # Global variable to hold the temperature data
    # Fetch temperature data for the selected city
    T_amb_list = get_temperature_for_city(city_name)
    if T_amb_list:
        print(f"Temperature data for {city_name} fetched successfully!")
        # Set the first temperature value as the current outside temperature for display
        current_temp = T_amb_list[0]  # Assuming we're showing the first value for now
        return current_temp
    else:
        print(f"Failed to fetch temperature data for {city_name}.")
        return 0

# Modify the set_parameters function to also set the 'Outside Temp' value
def set_parameters(params):
    Aw_entry.delete(0, tk.END)
    Aw_entry.insert(0, params['Aw'])
    Uw_entry.delete(0, tk.END)
    Uw_entry.insert(0, params['Uw'])
    Ar_entry.delete(0, tk.END)
    Ar_entry.insert(0, params['Ar'])
    Ur_entry.delete(0, tk.END)
    Ur_entry.insert(0, params['Ur'])
    T_sp_entry.delete(0, tk.END)
    T_sp_entry.insert(0, params['T_sp'])
    mass_of_water_entry.delete(0, tk.END)
    mass_of_water_entry.insert(0, params['Mass of Water in Hot Water Tank in kg'])
    
    initial_tank_temp_entry.delete(0, tk.END)
    initial_tank_temp_entry.insert(0, params['Initial Tank Temperature in K'])
    
    on_threshold_entry.delete(0, tk.END)
    on_threshold_entry.insert(0, params['Heat Pump On Threshold in K'])
    
    off_threshold_entry.delete(0, tk.END)
    off_threshold_entry.insert(0, params['Heat Pump Off Threshold in K'])
    
    A_tank_entry.delete(0, tk.END)
    A_tank_entry.insert(0, params['Tank Surface Area in m² (A_tank)'])
    
    # Set the City value (for use in fetching outside temperature)
    city_var.set(params['City'])
    
    # Fetch and display outside temperature for the city
    outside_temp = update_temperature_display(params['City'])
    # Update the outside temperature entry field
    outside_temp_entry.delete(0, tk.END)
    outside_temp_entry.insert(0, outside_temp)

# Create a new entry for displaying outside temperature
outside_temp_label = tk.Label(frame_params, text="Outside Temperature in °C (T_amb):")
outside_temp_label.grid(row=6, column=0, sticky='e')
outside_temp_entry = tk.Entry(frame_params)
outside_temp_entry.insert(0, "0")  # Default value
outside_temp_entry.grid(row=6, column=1)

# Modify the dropdown to include the city and temperature update
def create_parameter_dropdown(frame):
    dropdown = ttk.Combobox(frame, values=list(settings.keys()))
    dropdown.grid(pady=5, columnspan=2)

    def on_dropdown_select(event):
        selected_option = dropdown.get()
        if selected_option in settings:
            params = settings[selected_option]
            set_parameters(params)

    dropdown.bind("<<ComboboxSelected>>", on_dropdown_select)

# Parameter Entry Labels and Fields
tk.Label(frame_params, text="Wall Area in m² (Aw):").grid(row=0, column=0, sticky='e')
Aw_entry = tk.Entry(frame_params)
Aw_entry.insert(0, "0")  # Starting value
Aw_entry.grid(row=0, column=1)

tk.Label(frame_params, text="Wall U-value in W/m²K (Uw):").grid(row=1, column=0, sticky='e')
Uw_entry = tk.Entry(frame_params)
Uw_entry.insert(0, "0")  # Starting value
Uw_entry.grid(row=1, column=1)

tk.Label(frame_params, text="Roof Area in m² (Ar):").grid(row=2, column=0, sticky='e')
Ar_entry = tk.Entry(frame_params)
Ar_entry.insert(0, "0")  # Starting value
Ar_entry.grid(row=2, column=1)

tk.Label(frame_params, text="Roof U-value in W/m²K (Ur):").grid(row=3, column=0, sticky='e')
Ur_entry = tk.Entry(frame_params)
Ur_entry.insert(0, "0")  # Starting value
Ur_entry.grid(row=3, column=1)

tk.Label(frame_params, text="Set Point Temperature in K (T_sp):").grid(row=4, column=0, sticky='e')
T_sp_entry = tk.Entry(frame_params)
T_sp_entry.insert(0, "0")  # Starting value
T_sp_entry.grid(row=4, column=1)

tk.Label(frame_params, text="Tank Surface Area in m² (A_tank):").grid(row=5, column=0, sticky='e')
A_tank_entry = tk.Entry(frame_params)
A_tank_entry.insert(0, "0")  # Starting value
A_tank_entry.grid(row=5, column=1)

tk.Label(frame_params, text="Mass of Water in Hot Water Tank in kg:").grid(row=6, column=0, sticky='e')
mass_of_water_entry = tk.Entry(frame_params)
mass_of_water_entry.insert(0, "0")  # Starting value
mass_of_water_entry.grid(row=6, column=1)

tk.Label(frame_params, text="Initial Tank Temperature in K:").grid(row=7, column=0, sticky='e')
initial_tank_temp_entry = tk.Entry(frame_params)
initial_tank_temp_entry.insert(0, "0")  # Starting value
initial_tank_temp_entry.grid(row=7, column=1)

tk.Label(frame_params, text="Heat Pump On Threshold in K:").grid(row=8, column=0, sticky='e')
on_threshold_entry = tk.Entry(frame_params)
on_threshold_entry.insert(0, "0")  # Starting value
on_threshold_entry.grid(row=8, column=1)

tk.Label(frame_params, text="Heat Pump Off Threshold in K:").grid(row=9, column=0, sticky='e')
off_threshold_entry = tk.Entry(frame_params)
off_threshold_entry.insert(0, "0")  # Starting value
off_threshold_entry.grid(row=9, column=1)

# Add the city selection dropdown
tk.Label(frame_params, text="Select City for Outside Temperature:").grid(row=10, column=0, sticky='e')
city_var = tk.StringVar(value="Edinburgh")  # Default city is Edinburgh
city_dropdown = ttk.Combobox(frame_params, textvariable=city_var, values=list(cities.keys()))
city_dropdown.grid(row=10, column=1)

# Button to update temperature
tk.Button(frame_params, text="Update Temperature", command=update_temperature).grid(row=11, column=0, columnspan=2, pady=10)

# Create buttons for parameter sets A, B, C, D in the next row
param_dropdown_frame = tk.Frame(frame_params)
param_dropdown_frame.grid(row=12, column=0, columnspan=2, pady=10)
create_parameter_dropdown(param_dropdown_frame)

# Update the reset function to reset all parameters, including A_tank, to zero
def reset_parameters():
    entries = [Aw_entry, Uw_entry, Ar_entry, Ur_entry, T_sp_entry, mass_of_water_entry, 
               initial_tank_temp_entry, on_threshold_entry, off_threshold_entry, A_tank_entry]
    for entry in entries:
        entry.delete(0, tk.END)
        entry.insert(0, "0")

# Add the Reset button to the Parameters frame
tk.Button(frame_params, text="Reset to 0", command=reset_parameters).grid(row=13, column=0, columnspan=2, pady=10)

# Frame for Performance Metrics
frame_metrics = tk.Frame(root)
frame_metrics.pack(padx=10, pady=10)

# Create a section for performance metrics
tk.Label(frame_metrics, text="Select Performance Metric:").pack()

# Dropdown menu for performance metrics
performance_metric_var = tk.StringVar(value="Select Metric")
performance_metrics = ["Total Energy Consumption", "Average COP"]
metric_dropdown = ttk.Combobox(frame_metrics, textvariable=performance_metric_var, values=performance_metrics)
metric_dropdown.pack(pady=5)

# Function to show selected performance metric
def show_performance_metric():
    
    selected_metric = performance_metric_var.get()
    if selected_metric == "Select Metric":
        return  # Do nothing if no metric is selected

    plt.figure()
    if selected_metric == "Total Energy Consumption":
        # Dummy data for demonstration, replace with actual calculations
        time = np.linspace(0, 24, 100)
        energy = np.sin(time) + 1  # Replace with actual energy consumption data
        plt.plot(time, energy)
        plt.title("Energy Consumption Over Time")
        plt.ylabel("Energy (kWh)")

        
    elif selected_metric == "Average COP":
        # Dummy data for demonstration, replace with actual calculations
        # Plot COP over Time
        plt.figure(figsize=(12, 6))
        plt.plot(24, Heat_system.avg_cop, label='COP', color='purple')
        plt.xlabel('Time (hours)')
        plt.ylabel('COP')
        plt.title('Coefficient of Performance (COP) Over Time')
        plt.legend()
            
    plt.grid(True)
    plt.tight_layout()
    plt.show()

# Add button to show performance metric
tk.Button(frame_metrics, text="Show Metric", command=show_performance_metric).pack(pady=10)

# Frame for running simulation
frame_simulation = tk.Frame(root)
frame_simulation.pack(padx=10, pady=10)

# Define default values for U_cond, T_cond, U_tank, c_t
U_cond = 300
T_cond = 343.15
U_tank = 5
c_t = 837200


# Button to run simulation
tk.Button(frame_simulation, text="Run Simulation", command=lambda: run_simulation(
    float(Aw_entry.get()), float(Uw_entry.get()), float(Ar_entry.get()), float(Ur_entry.get()), 
    float(T_sp_entry.get()), float(U_cond), float(T_cond), float(U_tank), float(A_tank_entry.get()), 
    float(c_t), display_type='Temperature')).pack(pady=10)

# Start the main loop
root.mainloop()
