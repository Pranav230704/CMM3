import numpy as np
import yaml
from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
import tkinter as tk
from tkinter import ttk
from datetime import datetime
from meteostat import Point, Hourly
from scipy.optimize import curve_fit

# Define coordinates for additional cities
cities = {
    'Edinburgh': Point(55.9533, -3.1883),
    'Oslo': Point(59.9139, 10.7522),
    'Toronto': Point(43.65107, -79.347015),
    'Nairobi': Point(-1.286389, 36.817223),
    'Rio': Point(-22.9068, -43.1729),
    'Cape Town': Point(-33.9249, 18.4241)
}

# Define T_amb_list as a global variable
T_amb_list = []

# Function to get temperature for selected city
def get_temperature_for_city(city_name):
    global T_amb_list
    location = cities.get(city_name)
    if location:
        start = datetime(2023, 1, 1, 0)
        end = datetime(2023, 1, 2, 0)
        data = Hourly(location, start, end)
        data = data.fetch()
        T_amb_list = data['temp'].tolist()
        return T_amb_list
    else:
        return []

# Function to update temperature based on selected city
def update_temperature():
    selected_city = city_var.get()
    global T_amb_list
    T_amb_list = get_temperature_for_city(selected_city)
    if T_amb_list:
        print(f"Temperature data for {selected_city} fetched successfully!")
    else:
        print(f"Failed to fetch temperature data for {selected_city}.")

# Load COP data from YAML file
file_path1 = r'/Users/pranav/Downloads/heat_pump_cop_synthetic_full.yaml'
with open(file_path1, 'r') as file:
    cop_yaml = yaml.safe_load(file)
cop_temp = [i['outdoor_temp_C'] for i in cop_yaml['heat_pump_cop_data']]
cop_cop = [i['COP_noisy'] for i in cop_yaml['heat_pump_cop_data']]

class Heat_system:
    def __init__(self, Aw, Uw, Ar, Ur, T_amb_list, T_sp, U_cond, T_cond, U_tank, A_tank, c_t):
        self.Aw = Aw
        self.Uw = Uw
        self.Ar = Ar
        self.Ur = Ur
        self.T_amb_list = T_amb_list
        self.T_sp = T_sp
        self.U_cond = U_cond
        self.T_cond = T_cond
        self.U_tank = U_tank
        self.A_tank = A_tank
        self.c_t = c_t
        self.pump_on = False
        self.real_cop = []
        self.cop_values = []

    def Q_load(self):
        Q_loads = []
        for Tamb in self.T_amb_list:
            Q_load = (self.Aw * self.Uw * (Tamb + 273 - self.T_sp) + self.Ar * self.Ur * (Tamb + 273 - self.T_sp)) * -1
            Q_loads.append(Q_load)
        return Q_loads

    def cop(self, T_amb, a, b):
        delta_T = 60 - T_amb
        return a + b / delta_T

    popt, _ = curve_fit(lambda T, a, b: a + b / (60 - T), cop_temp, cop_cop)
    a, b = popt

    def Q_hp(self, T_tank, T_amb):
        if T_tank >= 60 + 273.15:
            self.pump_on = False
        elif T_tank <= 40 + 273.15:
            self.pump_on = True

        if self.pump_on:
            return 1.11 * (self.U_cond * (self.T_cond - T_tank))
        else:
            return 0

    def tank_temperature_ode(self, t, T_tank):
        T_amb = np.interp(t, np.linspace(0, 86400, len(self.T_amb_list)), self.T_amb_list)
        Load = np.interp(t, np.linspace(0, 86400, len(self.Q_load())), self.Q_load())
        Q_hp = self.Q_hp(T_tank, T_amb)
        Q_loss = self.U_tank * self.A_tank * (T_tank - T_amb)
        
        dTdt = (Q_hp - Load - Q_loss[0]) / self.c_t
        return dTdt

    def solve_tank_temperature(self, initial_tank_temp, total_time=86400, time_points=1000):
        t_eval = np.linspace(0, total_time, time_points)
        T_amb_interpolated = np.interp(t_eval, np.linspace(0, 86400, len(self.T_amb_list)), self.T_amb_list)
        solution = solve_ivp(self.tank_temperature_ode, [0, total_time], [initial_tank_temp], t_eval=t_eval, method="RK45", max_step=100)

        self.cop_values = [self.cop(T_amb, self.a, self.b) for T_amb in T_amb_interpolated]
        Q_hp_values = [self.Q_hp(T_tank, T_amb) for T_tank, T_amb in zip(solution.y[0], T_amb_interpolated)]
        Q_hp_total = np.trapz(Q_hp_values, solution.t)
        avg_cop = np.mean(self.real_cop) if self.real_cop else 0

        T_tank_values = solution.y[0] - 273.15
        time_values = solution.t

        return time_values, T_tank_values, Q_hp_total, avg_cop

def run_simulation(Aw, Uw, Ar, Ur, T_sp, U_cond, T_cond, U_tank, A_tank, c_t):
    if not T_amb_list:
        print("Temperature data not available!")
        return
    
    heat_system = Heat_system(Aw, Uw, Ar, Ur, T_amb_list, T_sp, U_cond, T_cond, U_tank, A_tank, c_t)
    initial_tank_temp = 318.15
    time_values, T_tank_values, Q_hp_total, avg_cop = heat_system.solve_tank_temperature(initial_tank_temp)
    
    plt.figure(figsize=(12, 6))
    plt.subplot(1, 2, 1)
    plt.plot(time_values / 3600, T_tank_values, label="Tank Temperature", linewidth=1.5)
    plt.axhline(y=60, color="red", linestyle="--", label="Heat Pump Off Threshold (60°C)")
    plt.axhline(y=40, color="blue", linestyle="--", label="Heat Pump On Threshold (40°C)")
    plt.xlabel("Time (hours)")
    plt.ylabel("Tank Temperature (°C)")
    plt.title("Tank Temperature Over Time")
    plt.legend(loc="upper right")
    plt.grid(True)

    plt.subplot(1, 2, 2)
    plt.plot(time_values / 3600, heat_system.cop_values, label="COP", color="purple")
    plt.xlabel("Time (hours)")
    plt.ylabel("COP")
    plt.title("Coefficient of Performance (COP) Over Time")
    plt.legend()
    plt.grid(True)
    
    total_energy_kwh = Q_hp_total / (3.6e6)
    plt.figtext(0.5, 0.01, f"Total Energy Consumption: {total_energy_kwh:.2f} kWh", ha="center", fontsize=12, color="green")

    plt.tight_layout()
    plt.show()

root = tk.Tk()
root.title("Heat Pump Simulation")

def set_parameters(params):
    Aw_entry.delete(0, tk.END)
    Aw_entry.insert(0, params['Aw'])
    Uw_entry.delete(0, tk.END)
    Uw_entry.insert(0, params['Uw'])
    Ar_entry.delete(0, tk.END)
    Ar_entry.insert(0, params['Ar'])
    Ur_entry.delete(0, tk.END)
    Ur_entry.insert(0, params['Ur'])
    T_sp_entry.delete(0, tk.END)
    T_sp_entry.insert(0, params['T_sp'])
    mass_of_water_entry.delete(0, tk.END)
    mass_of_water_entry.insert(0, params['Mass of Water in Hot Water Tank in kg'])
    A_tank_entry.delete(0, tk.END)
    A_tank_entry.insert(0, params['Tank Surface Area in m² (A_tank)'])
    city_var.set(params['City'])
    outside_temp_entry.delete(0, tk.END)
    outside_temp_entry.insert(0, update_temperature_display(params['City']))

frame_params = tk.Frame(root)
frame_params.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
city_var = tk.StringVar(value="Edinburgh")
city_dropdown = ttk.Combobox(frame_params, textvariable=city_var, values=list(cities.keys()))
city_dropdown.grid(row=10, column=1)

tk.Label(frame_params, text="Run Simulation").grid(row=13, column=0, columnspan=2, pady=10)
tk.Button(frame_params, text="Run Simulation", command=lambda: run_simulation(
    float(Aw_entry.get()), float(Uw_entry.get()), float(Ar_entry.get()), float(Ur_entry.get()), 
    float(T_sp_entry.get()), 300, 343.15, 5, float(A_tank_entry.get()), 
    float(mass_of_water_entry.get()) * 4186)).grid(row=14, column=0, columnspan=2, pady=10)

root.mainloop()
